<script>
(function () {
  'use strict';

  const DEBUG = true;

  const CONFIG = {
    SINGLE_PAY_PRICE: '$1,997',
    SINGLE_PAY_VALUES: ['0']
  };

  const TURBO_PRODUCT_ID_FALLBACK = '10';  // Fallback Turbo Pack product ID from latest markup
  let detectedTurboProductId = null;
  let loggedFallbackProductId = false;
  const TURBO_UPDATE_TARGETS = [
    'ORDER_FORM_PRODUCT_LIST',
    'ORDER_FORM_BILLING_ENTRY',
    'ORDER_FORM_SUMMARY',
    'UP_SELLS',
    'PAYMENT_PLANS',
    'PAYMENT_SELECTION',
    'ORDER_FORM_SHIPPING_ENTRY',
    'SHIPPING_OPTIONS',
    'CHECKOUT_LINKS'
  ];

  const raf = window.requestAnimationFrame
    ? window.requestAnimationFrame.bind(window)
    : (cb) => window.setTimeout(cb, 16);

  const $ = (selector, root) => (root || document).querySelector(selector);
  const $$ = (selector, root) => Array.from((root || document).querySelectorAll(selector));

  let updateScheduled = false;
  let turboAddWrapperCache = null;
  let isRemovingTurboPack = false;
  let lastRemovalTime = 0;
  let lastKnownSingleSelection = null;
  const FORCED_REMOVAL_COOLDOWN_MS = 5000;
  let pendingForcedRemovalTimeout = null;
  let lastForcedRemovalAttempt = 0;

  function logDebug() {
    if (!DEBUG) return;
    const args = Array.prototype.slice.call(arguments);
    args.unshift('[SinglePayDebug]');
    console.log.apply(console, args);
  }

  function scheduleUpdate(delayMs) {
    if (updateScheduled) return;
    updateScheduled = true;

    const hasNumericDelay = typeof delayMs === 'number' && delayMs > 0;
    logDebug('scheduleUpdate invoked' + (hasNumericDelay ? ' with delay ' + delayMs + 'ms' : ''));
    
    const runUpdate = () => {
      updateScheduled = false;
      logDebug('scheduleUpdate running initialize');
      initialize();
    };
    
    if (hasNumericDelay) {
      window.setTimeout(runUpdate, delayMs);
    } else {
      raf(runUpdate);
    }
  }



  function getPaymentRadios() {
    return $$('input[type="radio"][name="payPlanId"], input[type="radio"][name*="payPlan"], input[type="radio"][name*="payment"]');
  }

  function getLabelForInput(input) {
    if (!input) return null;
    if (input.id) {
      const explicitLabel = $(`label[for="${input.id}"]`);
      if (explicitLabel) return explicitLabel;
    }
    return input.closest('label');
  }

  function findSinglePayRadio() {
    const radios = getPaymentRadios();
    logDebug('Evaluating payment radios', radios.length);
    
    // Filter to ONLY payment plan radios (not payment type like creditcard/paypal)
    const payPlanRadios = radios.filter((radio) => radio.name === 'payPlanId');
    
    // Log all radio values for debugging
    radios.forEach((radio, index) => {
      const label = getLabelForInput(radio);
      logDebug(`Radio ${index}: value="${radio.value}", name="${radio.name}", checked=${radio.checked}, label="${label ? label.textContent.trim().substring(0, 50) : 'N/A'}"`);
    });

    // First try to find by "SINGLE PAYMENT" text in label - only check payment plan radios
    for (const radio of payPlanRadios) {
      const label = getLabelForInput(radio);
      if (label && label.textContent && label.textContent.toUpperCase().includes('SINGLE PAYMENT')) {
        logDebug('Single pay matched by label text', label.textContent.trim(), 'value:', radio.value);
        return { radio, label };
      }
    }

    // Then try to match by configured value - only check payment plan radios
    for (const value of CONFIG.SINGLE_PAY_VALUES) {
      const match = payPlanRadios.find((radio) => (radio.value || '').trim() === value);
      if (match) {
        const label = getLabelForInput(match);
        if (label) {
          logDebug('Single pay matched by value', value);
          return { radio: match, label };
        }
      }
    }

    // Fallback: use first PAYMENT PLAN radio (not first radio overall)
    const fallbackRadio = payPlanRadios[0];
    if (fallbackRadio) {
      const label = getLabelForInput(fallbackRadio);
      if (label) {
        logDebug('Using fallback radio (first payment plan radio)');
        return { radio: fallbackRadio, label };
      }
    }

    return null;
  }

  let priceObserver = null;
  let priceUpdateCount = 0;

  function applySinglePayPrice(single) {
    const { label } = single;
    
    logDebug('=== applySinglePayPrice called ===');
    logDebug('  Label element:', label);
    logDebug('  Label text:', label.textContent.trim().substring(0, 100));
    
    // Find price text in the label and replace it with $1,997
    const priceRegex = /\$[\d,]+(?:\.\d{2})?/;
    
    const updatePrice = (source) => {
      priceUpdateCount++;
      logDebug(`[Price Update #${priceUpdateCount}] Source: ${source || 'unknown'}`);
      
      const walker = document.createTreeWalker(label, NodeFilter.SHOW_TEXT, null, false);
      let node;
      let updated = false;
      
      while (node = walker.nextNode()) {
        if (priceRegex.test(node.textContent)) {
          const currentPrice = node.textContent.match(priceRegex)[0];
          logDebug(`  Current price in label: ${currentPrice}`);
          logDebug(`  Target price: ${CONFIG.SINGLE_PAY_PRICE}`);
          logDebug(`  Needs update: ${currentPrice !== CONFIG.SINGLE_PAY_PRICE}`);
          
          if (currentPrice !== CONFIG.SINGLE_PAY_PRICE) {
            const oldText = node.textContent;
            node.textContent = node.textContent.replace(priceRegex, CONFIG.SINGLE_PAY_PRICE);
            logDebug(`  âœ“ Updated price from ${currentPrice} to ${CONFIG.SINGLE_PAY_PRICE}`);
            logDebug(`  Full text changed from: "${oldText}"`);
            logDebug(`  Full text changed to: "${node.textContent}"`);
            updated = true;
          } else {
            logDebug(`  âœ“ Price already correct at ${CONFIG.SINGLE_PAY_PRICE}`);
          }
          break;
        }
      }
      
      if (!updated) {
        logDebug('  No price update needed or no price found');
      }
      
      return updated;
    };
    
    // Initial price update
    logDebug('Performing initial price update...');
    updatePrice('initial');
    
    // Disconnect existing observer if any
    if (priceObserver) {
      logDebug('Disconnecting existing price observer');
      priceObserver.disconnect();
    }
    
    // Set up observer to keep price locked at $1,997
    if (window.MutationObserver) {
      priceObserver = new MutationObserver((mutations) => {
        logDebug(`Price observer triggered by ${mutations.length} mutation(s)`);
        mutations.forEach((mutation, index) => {
          logDebug(`  Mutation ${index + 1}: type=${mutation.type}, target=`, mutation.target);
          if (mutation.type === 'characterData') {
            logDebug(`    Old value: "${mutation.oldValue}"`);
            logDebug(`    New value: "${mutation.target.textContent}"`);
          }
        });
        updatePrice('observer');
      });
      priceObserver.observe(label, {
        childList: true,
        subtree: true,
        characterData: true,
        characterDataOldValue: true
      });
      logDebug('âœ“ Price observer attached to lock price at', CONFIG.SINGLE_PAY_PRICE);
    }
  }

  function parseProductIdFromHref(href) {
    if (!href) return null;
    const match = href.match(/ajaxSubmitForm\([^,]+,\s*(?:true|false)\s*,\s*['"](\d+)['"]/i);
    return match ? match[1] : null;
  }

  function detectTurboProductId() {
    const roots = [
      document.getElementById('ORDER_FORM_PRODUCT_LIST'),
      document.getElementById('UP_SELLS'),
      document.body
    ].filter(Boolean);

    for (const root of roots) {
      const candidates = root.querySelectorAll('a[href*="ajaxSubmitForm"], button[href*="ajaxSubmitForm"], button[data-href*="ajaxSubmitForm"]');
      for (const el of candidates) {
        const text = (el.textContent || '').toLowerCase();
        const context = ((el.closest('[class*="upsell" i], .spiffy-upsell, .infusion-option, tr, li, div, section, article') || el).textContent || '').toLowerCase();
        if (!/turbo pack/.test(text) && !/turbo pack/.test(context)) continue;

        const href = el.getAttribute('href') || el.getAttribute('data-href') || el.getAttribute('onclick') || '';
        const productId = parseProductIdFromHref(href);
        if (productId) {
          if (detectedTurboProductId !== productId) {
            logDebug('Detected Turbo Pack product ID from DOM:', productId);
            detectedTurboProductId = productId;
            loggedFallbackProductId = false;
          }
          return productId;
        }
      }
    }

    return detectedTurboProductId;
  }

  function getTurboProductId() {
    const detected = detectTurboProductId();
    if (detected) {
      return detected;
    }

    if (!detectedTurboProductId) {
      detectedTurboProductId = TURBO_PRODUCT_ID_FALLBACK;
    }

    if (!loggedFallbackProductId && detectedTurboProductId === TURBO_PRODUCT_ID_FALLBACK) {
      logDebug('Using fallback Turbo Pack product ID:', TURBO_PRODUCT_ID_FALLBACK);
      loggedFallbackProductId = true;
    }

    return detectedTurboProductId;
  }

  function targetContainsProductId(target, productId) {
    if (!target || !productId) return false;
    return target.includes(`'${productId}'`) || target.includes(`"${productId}"`);
  }

  function toggleElementVisibility(element, isVisible) {
    if (!element) return;
    const attrName = 'data-single-pay-hidden';
    if (isVisible) {
      if (element.getAttribute(attrName) === 'true') {
        element.style.removeProperty('display');
        element.removeAttribute(attrName);
      }
      return;
    }

    if (element.getAttribute(attrName) !== 'true') {
      element.setAttribute(attrName, 'true');
    }
    element.style.setProperty('display', 'none', 'important');
  }

  function findTurboHeadingElement(wrapper) {
    if (!wrapper) return null;

    const headingSelectors = ['h1', 'h2', 'h3', 'h4', '.spiffy-upsell-title', '.upsellHeadline'];
    for (const selector of headingSelectors) {
      const directMatch = wrapper.matches && wrapper.matches(selector) ? wrapper : null;
      const nestedMatch = wrapper.querySelector ? wrapper.querySelector(selector) : null;
      const candidate = directMatch || nestedMatch;
      if (candidate && /you might also be interested|turbo pack/i.test(candidate.textContent || '')) {
        return candidate;
      }
    }

    let sibling = wrapper.previousElementSibling;
    while (sibling) {
      const text = (sibling.textContent || '').trim();
      if (text) {
        if (/you might also be interested/i.test(text)) {
          return sibling;
        }
        break;
      }
      sibling = sibling.previousElementSibling;
    }

    return null;
  }

  function findTurboAddWrapper() {
    if (turboAddWrapperCache && document.contains(turboAddWrapperCache)) {
      return turboAddWrapperCache;
    }

    turboAddWrapperCache = null;

    const productId = getTurboProductId();
    if (!productId) return null;

    const roots = [
      document.getElementById('UP_SELLS'),
      document.getElementById('content'),
      document.body
    ].filter(Boolean);

    for (const root of roots) {
      const elements = root.querySelectorAll('a[href*="ajaxSubmitForm"], button[href*="ajaxSubmitForm"], button[data-href*="ajaxSubmitForm"]');
      for (const el of elements) {
        const context = ((el.closest('[class*="upsell" i], .spiffy-upsell, .infusion-option, tr, li, div, section, article') || el).textContent || '');
        const attrTargets = ['href', 'data-href', 'onclick']
          .map((attr) => el.getAttribute(attr))
          .filter(Boolean);
        const matchesProduct = attrTargets.some((target) => targetContainsProductId(target, productId));
        if (!matchesProduct && !/turbo pack/i.test(context)) {
          continue;
        }

        const wrapper = el.closest('[class*="upsell" i], .spiffy-upsell, .spiffy-upsell-wrapper, .infusion-option, tr, li, div, section, article');
        if (wrapper) {
          logDebug('Caching Turbo Pack upsell wrapper');
          turboAddWrapperCache = wrapper;
          return turboAddWrapperCache;
        }
      }
    }

    return null;
  }

  function isTurboAddButton(element) {
    const text = element.textContent || '';
    if (!/add to order/i.test(text)) return false;

    const href = element.getAttribute('href') || element.getAttribute('data-href') || element.getAttribute('onclick') || '';
    const productId = getTurboProductId();
    if (targetContainsProductId(href, productId)) return true;

    const context = (element.closest('[class*="upsell" i], .spiffy-upsell, .infusion-option, tr, li, div, section, article') || element.parentElement || element).textContent || '';
    return /turbo pack/i.test(context);
  }

  function findUpsellSections() {
    const sections = [];

    const upSellRoot = document.getElementById('UP_SELLS');
    if (upSellRoot) {
      sections.push(upSellRoot);
      logDebug('Found UP_SELLS section by ID');
    }

    const turboWrapper = findTurboAddWrapper();
    if (turboWrapper) {
      sections.push(turboWrapper);
      logDebug('Found Turbo Pack wrapper element for visibility control');

      const heading = findTurboHeadingElement(turboWrapper);
      if (heading) {
        sections.push(heading);
        logDebug('Found Turbo Pack heading element for visibility control');
      }
    }

    const uniqueSections = sections.filter((section, index, array) => array.indexOf(section) === index);
    logDebug('findUpsellSections found', uniqueSections.length, 'section(s)');
    return uniqueSections;
  }

  function setUpsellVisibility(isVisible) {
    const sections = findUpsellSections();
    logDebug('setUpsellVisibility setting', isVisible ? 'visible' : 'hidden', 'for', sections.length, 'sections');
    
    if (!sections.length) {
      logDebug('WARNING: No upsell sections found!');
      return;
    }

    sections.forEach((section) => {
      toggleElementVisibility(section, isVisible);
    });
  }

  function turboPackIsInCart() {
    const productList = document.getElementById('ORDER_FORM_PRODUCT_LIST');
    if (!productList) {
      logDebug('turboPackIsInCart: ORDER_FORM_PRODUCT_LIST not found');
      return false;
    }
    
    // Check both by text content and by product ID in links
    const rows = Array.from(productList.querySelectorAll('tr'));
    const foundByText = rows.some((row) => /turbo pack/i.test(row.textContent || ''));
    const productId = getTurboProductId();
    const foundById = rows.some((row) => {
      const links = row.querySelectorAll('a[href*="ajaxSubmitForm"], button[href*="ajaxSubmitForm"], button[data-href*="ajaxSubmitForm"]');
      return Array.from(links).some(link => {
        const candidates = ['href', 'data-href', 'onclick']
          .map((attr) => link.getAttribute(attr))
          .filter(Boolean);
        return candidates.some(target => targetContainsProductId(target, productId));
      });
    });
    
    const inCart = foundByText || foundById;
    logDebug(`turboPackIsInCart: ${inCart} (foundByText: ${foundByText}, foundById: ${foundById})`);
    return inCart;
  }

  function findTurboRemoveTrigger() {
    const productList = document.getElementById('ORDER_FORM_PRODUCT_LIST');
    if (!productList) {
      logDebug('findTurboRemoveTrigger: ORDER_FORM_PRODUCT_LIST not found');
      return null;
    }

    const productId = getTurboProductId();
    const trigger = Array.from(productList.querySelectorAll('a[href*="ajaxSubmitForm"], button[href*="ajaxSubmitForm"], button[data-href*="ajaxSubmitForm"]')).find((el) => {
      const text = el.textContent || '';
      const candidates = ['href', 'data-href', 'onclick']
        .map((attr) => el.getAttribute(attr))
        .filter(Boolean);
      const isRemoveLink = /remove/i.test(text);
      const hasTurboId = candidates.some(target => targetContainsProductId(target, productId));
      
      if (isRemoveLink && hasTurboId) {
        logDebug('findTurboRemoveTrigger: Found remove link', { text, productId });
        return true;
      }
      return false;
    }) || null;
    
    if (!trigger) {
      logDebug('findTurboRemoveTrigger: No remove link found for product ID', productId);
    }
    return trigger;
  }

  function removeTurboPackFromCart(forceRemove = false, options = {}) {
    const precheckedInCart = options.precheckedInCart;
    const inCart = typeof precheckedInCart === 'boolean' ? precheckedInCart : turboPackIsInCart();
    const productList = document.getElementById('ORDER_FORM_PRODUCT_LIST');
    
    logDebug('removeTurboPackFromCart called');
    logDebug('  - inCart:', inCart);
    logDebug('  - isRemoving:', isRemovingTurboPack);
    logDebug('  - productList exists:', Boolean(productList));
    
    if (productList) {
      const rows = productList.querySelectorAll('tr');
      logDebug('  - cart has', rows.length, 'rows');
      rows.forEach((row, i) => {
        const text = row.textContent || '';
        logDebug('    Row', i + ':', text.substring(0, 80));
      });
    }
    
    if (!inCart && !forceRemove) {
      logDebug('Turbo Pack not detected in cart, skipping removal');
      return;
    }

    if (!inCart && forceRemove) {
      const now = Date.now();
      const sinceLastAttempt = now - lastForcedRemovalAttempt;
      if (sinceLastAttempt < FORCED_REMOVAL_COOLDOWN_MS) {
        logDebug('Skipping forced Turbo Pack removal; last attempt was', sinceLastAttempt, 'ms ago');
        return;
      }
      logDebug('Turbo Pack not detected in cart, forcing removal attempt via ajax/trigger');
      lastForcedRemovalAttempt = now;
    }
    
    if (isRemovingTurboPack) {
      logDebug('Already removing Turbo Pack, skipping');
      return;
    }

    logDebug('Attempting to remove Turbo Pack from cart');

    const identifierInput = $('#identifier');
    const identifier = identifierInput ? identifierInput.value : '';
    const productId = getTurboProductId();
    const removeTrigger = inCart ? findTurboRemoveTrigger() : null;
    const canCallAjax = Boolean(
      identifier &&
      window.Infusion &&
      Infusion.Ecomm &&
      Infusion.Ecomm.OrderForms &&
      typeof Infusion.Ecomm.OrderForms.ajaxSubmitForm === 'function'
    );

    if (!inCart) {
      logDebug('Cart already clean; skipping removal mechanics to avoid refresh');
      return;
    }

    isRemovingTurboPack = true;
    lastRemovalTime = Date.now();

    const releaseLock = () => {
      window.setTimeout(() => {
        isRemovingTurboPack = false;
        logDebug('Removal lock released');
      }, 2000);
    };

    try {
      if (canCallAjax) {
        logDebug('Removing Turbo Pack via ajaxSubmitForm');
        Infusion.Ecomm.OrderForms.ajaxSubmitForm(
          'orderForm',
          false,
          productId,
          0,
          identifier,
          'RENDER_ORDER_FORM',
          TURBO_UPDATE_TARGETS.slice()
        );
        turboAddWrapperCache = null;
        scheduleUpdate(300);
      } else if (removeTrigger) {
        logDebug('Falling back to remove trigger click');
        removeTrigger.click();
        turboAddWrapperCache = null;
        scheduleUpdate(300);
      } else {
        logDebug('ERROR: No way to remove Turbo Pack found');
      }
    } catch (error) {
      console.error('Turbo Pack removal failed', error);
    } finally {
      releaseLock();
    }
  }

  function syncTurboPackState(single) {
    const hasSingle = Boolean(single);
    let isSingleSelected = hasSingle ? Boolean(single.radio.checked) : null;

    if (hasSingle) {
      lastKnownSingleSelection = isSingleSelected;
    } else if (lastKnownSingleSelection !== null) {
      isSingleSelected = lastKnownSingleSelection;
      logDebug('Using cached single pay selection state because radio is unavailable:', isSingleSelected);
    }

    if (isSingleSelected === null) {
      logDebug('Unable to determine single pay selection; leaving upsell visibility unchanged');
      return;
    }

    logDebug('=== syncTurboPackState called ===');
    logDebug('syncTurboPackState details:', {
      hasSingle,
      singleRadioValue: single ? single.radio.value : null,
      singleRadioName: single ? single.radio.name : null,
      singleRadioChecked: single ? single.radio.checked : null,
      isSingleSelected
    });

    // Log all currently checked radios
    const allRadios = getPaymentRadios();
    const checkedRadios = allRadios.filter(r => r.checked);
    logDebug(`Currently checked radios (${checkedRadios.length}):`, checkedRadios.map(r => `${r.name}=${r.value}`));

    const targetVisibility = !isSingleSelected;
    logDebug(`Setting upsell visibility to: ${targetVisibility ? 'VISIBLE' : 'HIDDEN'}`);

    setUpsellVisibility(targetVisibility);

    if (isSingleSelected) {
      const inCartNow = turboPackIsInCart();

      if (hasSingle) {
        if (inCartNow) {
          logDebug('âœ“ Single pay IS selected and Turbo Pack is in cart â†’ Removing immediately');
          removeTurboPackFromCart(false, { precheckedInCart: inCartNow });
        } else {
          const now = Date.now();
          const sinceLastAttempt = now - lastForcedRemovalAttempt;
          if (!pendingForcedRemovalTimeout && sinceLastAttempt > FORCED_REMOVAL_COOLDOWN_MS) {
            logDebug('Scheduling safety Turbo Pack removal after short delay');
            pendingForcedRemovalTimeout = window.setTimeout(() => {
              pendingForcedRemovalTimeout = null;
              removeTurboPackFromCart(true, { precheckedInCart: inCartNow });
            }, 200);
          } else if (pendingForcedRemovalTimeout) {
            logDebug('Turbo removal already scheduled; awaiting execution');
          } else {
            logDebug('Skipping forced Turbo removal; cooldown still active');
          }
        }
      } else {
        logDebug('Single pay assumed via cached state; skipping removal because radio is unavailable');
      }
    } else {
      if (pendingForcedRemovalTimeout) {
        window.clearTimeout(pendingForcedRemovalTimeout);
        pendingForcedRemovalTimeout = null;
        logDebug('Cleared pending Turbo removal because single pay is no longer selected');
      }
      logDebug('âœ“ Single pay NOT selected â†’ Showing upsells (Turbo Pack can be added)');
    }
    
    logDebug('=== syncTurboPackState complete ===');
  }

  function onRadioChange() {
    scheduleUpdate();
  }

  function attachPaymentListeners() {
    getPaymentRadios().forEach((radio) => {
      radio.removeEventListener('change', onRadioChange);
      radio.addEventListener('change', onRadioChange);
    });
  }

  // Override Keap's unhideOrderFormSections to prevent it from re-showing hidden sections
  function overrideKeapUnhide() {
    if (window.Infusion && Infusion.Ecomm && Infusion.Ecomm.OrderForms) {
      const original = Infusion.Ecomm.OrderForms.unhideOrderFormSections;
      Infusion.Ecomm.OrderForms.unhideOrderFormSections = function() {
        logDebug('Intercepted unhideOrderFormSections call');
        if (original) {
          original.apply(this, arguments);
        }
        // Re-apply our visibility logic after Keap tries to unhide
        window.setTimeout(() => {
          const single = findSinglePayRadio();
          if (single && single.radio.checked) {
            logDebug('Re-hiding upsells after unhideOrderFormSections');
            setUpsellVisibility(false);
          }
        }, 50);
      };
      logDebug('Overrode unhideOrderFormSections');
    }
  }

  function initialize() {
    logDebug('â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•');
    logDebug('    INITIALIZE CALLED');
    logDebug('â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•');
    
    const single = findSinglePayRadio();
    logDebug('initialize results:', { 
      hasSingle: Boolean(single),
      singleValue: single ? single.radio.value : null,
      singleChecked: single ? single.radio.checked : null
    });

    const productId = getTurboProductId();
    logDebug('Current Turbo Pack product ID in use:', productId);
    
    if (single) {
      logDebug('Applying price lock to single pay option...');
      applySinglePayPrice(single);
    } else {
      logDebug('WARNING: No single pay radio found, skipping price application');
    }

    logDebug('Attaching payment listeners...');
    attachPaymentListeners();
    
    logDebug('Syncing Turbo Pack state...');
    syncTurboPackState(single);
    
    logDebug('â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•');
    logDebug('    INITIALIZE COMPLETE');
    logDebug('â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•');
  }

  // Run override early
  overrideKeapUnhide();

  function shouldReactToMutation(mutation) {
    // Don't react to mutations shortly after removing Turbo Pack to avoid interference
    const timeSinceRemoval = Date.now() - lastRemovalTime;
    if (timeSinceRemoval < 1500) {
      // logDebug('Ignoring mutation - too soon after removal (' + timeSinceRemoval + 'ms)'); // Too noisy
      return false;
    }

    if (turboAddWrapperCache && !document.contains(turboAddWrapperCache)) {
      turboAddWrapperCache = null;
    }

    if (mutation.type === 'childList') {
      const changedNodes = [
        ...Array.from(mutation.addedNodes || []),
        ...Array.from(mutation.removedNodes || [])
      ];
      const shouldReact = changedNodes.some((node) => {
        if (!(node instanceof Element)) return false;
        // React to radio button changes
        if (node.matches('input[type="radio"]')) return true;
        if (node.querySelector && node.querySelector('input[type="radio"]')) return true;
        // Also react to cart/product list changes (for Turbo Pack detection)
        if (node.id === 'ORDER_FORM_PRODUCT_LIST' || node.closest('#ORDER_FORM_PRODUCT_LIST')) return true;
        if (node.id === 'UP_SELLS' || node.closest('#UP_SELLS')) return true;
        if (/turbo pack/i.test(node.textContent || '')) return true;
        return false;
      });
      
      if (shouldReact) {
        logDebug('ğŸ“¡ Mutation detected: childList change affecting radio buttons or product list');
      }
      return shouldReact;
    }

    if (mutation.type === 'attributes' && mutation.target instanceof Element) {
      const shouldReact = mutation.target.matches('input[type="radio"]');
      if (shouldReact) {
        logDebug('ğŸ“¡ Mutation detected: radio button attribute changed', {
          target: mutation.target,
          attribute: mutation.attributeName,
          value: mutation.target.getAttribute(mutation.attributeName)
        });
      }
      return shouldReact;
    }

    return false;
  }

  const targetNode = document.getElementById('content') || document.body;
  const MutationObserverCtor = window.MutationObserver || window.WebKitMutationObserver;

  if (MutationObserverCtor && targetNode) {
    const observer = new MutationObserverCtor((mutations) => {
      if (mutations.some(shouldReactToMutation)) {
        // Add a delay to allow DOM to fully settle after Keap's AJAX updates
        scheduleUpdate(100);
      }
    });
    observer.observe(targetNode, { childList: true, subtree: true, attributes: true, attributeFilter: ['checked'] });
  }

  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', scheduleUpdate, { once: true });
  } else {
    scheduleUpdate();
  }

  window.addEventListener('load', scheduleUpdate);
  window.addEventListener('hashchange', scheduleUpdate);
  window.addEventListener('popstate', scheduleUpdate);
})();
</script>
